<!DOCTYPE html>
<html>
  <head>
    <title></title>
    <link rel="stylesheet" href="assets/css/style.css" />
    <script
      src="https://code.jquery.com/jquery-3.3.1.js"
      integrity="sha256-2Kok7MbOyxpgUVvAk/HJ2jigOSYS2auK4Pfzbm7uH60="
      crossorigin="anonymous"
    ></script>
    <script>
      $(function () {
        $("#header").load("header.html");
        $("#footer").load("footer.html");
      });
    </script>
    <script src="assets/js/codeformatter.js"></script>
  </head>
  <body>
    <div class="sticky" id="header"></div>
    <div class="wrapper">
      <section class="introduction">
        <div class="title">
          <h1>Escape from Purrrgatory</h1>
          <h3 style="color: #d7cfbe">
            Early 2021 marked the true beginning of my journey in game
            development. Escape from Purrrgatory was the first project outside
            of personal prototypes and mini projects that I had the opportunity
            to work on. I learned alot from my teammates about the whole process
            of developing a game from scratch. It was a valuable and fun
            experience that only further deepened my desire to develop games.
          </h3>
        </div>
      </section>
      <section class="projectcontent">
        <div class="contentwrap">
          <image class="projectimg" src="assets/images/purrrgatory.png"></image>
          <div class="contentdescription">
            <h2 style="text-transform: uppercase">The idea</h2>
            <p>
              Escape from Purrrgatory is a turn based isometric tactics game in
              which you control 4 characters at the same time. The characters
              are bound to each other and standing back to back. They all move
              and attack at the same time. The characters can be rotated in
              either clockwise or counterclockwise directions. Whenever the
              characters attack, they lose attackpower for the next attack.
              After issuing 2 moves while in interest range of an enemy, the
              turn ends and all enemies move and possibly attack. After the
              enemy turn, the gameplay loop starts over with the player turn.
            </p>
          </div>
        </div>
        <div class="contentwrap">
          <image class="projectimg" src="assets/images/purrrgatory.png"></image>
          <div class="contentdescription">
            <h2 style="text-transform: uppercase">The process</h2>
            <p>
              The whole idea for the games' design was thought out by Lena.
              Anastasiia and Lena discussed and decided on the art direction
              together. To keep things organized, we utilized a Trello board.
              Daniil and I held regular feature meetings to discuss splitting up
              the tasks between us and reviewing implemented features. It was
              very helpful to work together with a seasoned programmer as I
              learned alot about writing cleaner code and keeping perfomance in
              mind thanks to Daniil's feedbacks. Finally we ended up with a
              finished introduction level including dialogs, AI Pathfinding, UI
              implementation and all major gameplay features such as powerups
              and three different types of enemies.
            </p>
          </div>
        </div>
        <div class="contentwrap">
          <div class="contentdescription">
            <h2 style="text-transform: uppercase">The features</h2>
            <p>
              The game is fully controlled with the mouse. Attacking and turning
              works via UI buttons, whereas movement is done by clicking on a
              valid movement tile. Two basic functions handled the logic for
              finding valid movement options:
            </p>
            <pre class="highlight"><code class="language-csharp">
    public void CheckPossibleMovements() {
      for(int i = 0; i &lt; directionArray.Length; i++) {
        if(CheckForCollidableObjects(directionArray[i], collidableObjects))
          possibleMoveTiles[i].SetActive(false);
        else
          possibleMoveTiles[i].SetActive(true);
      }
    }
    private void CheckForCollidableObjects(Vector3 direction, LayerMask layer) {
      Collider2D col; 
      foreach(Transform character in Characters) 
      { 
        col  = Physics2D.OverlapPoint(character.position + direction, layer); 
        if (col != null) 
          return true; 
      } 
      return false; 
    }</code>
            </pre>
            <p>
              The 4 movement directions are stored as corresponding vectors in
              an array. In every players' turn and after every movement, it is
              checked if any collidable objects are in place of any of the 4
              directions correlated to the 4 characters' positions. If so, the
              movement option is invalidated by setting the movement tile to
              false. If there is no collidable object in the corresponding
              direction, the movement tile is activated and can be clicked to
              move towards.
            </p>
            <br />
            <p>
              The games' turnbased system consists of two states, the player
              turn and the enemy turn. Therefore we decided for a simple
              implementation tracking a boolean flag for the players' turn. If
              the player used up their pool of valid options, they have to
              confirm their turn by clicking the end turn button. The logic is
              implemented as such:
            </p>
            <pre class="hightlight"><code class="language-csharp">
    public void IncrementMoves() {
      playerMoves++;
      UpdateShortestPath();

      if(playerMoves == 2) {
        LockControl();
      }
    }

    //Updates the shortest path from any enemy in interest range to the player
    private void UpdateShortesPath() {
      foreach(Enemy enemy in enemiesInRange) {
        enemy.FindShortestPath();
      }
    
    private void LockControl() {
      if(enemiesInRange.Count &LessSlantEqual; 0) {
        playerMoves = 0;
        return;
      }
      FadeTiles(possibleMoveTiles, new Color(0.4f, 0.4f, 0.4f, 0.4f));
      isPlayerTurn = false;
    }

    private void UnlockControl() {
      FadeTiles(possibleMoveTiles, new Color(1f, 1f, 1f, 1f));
      playerMoves = 0;
      isPlayerTurn = true;
    }

    //The function called by clicking the end turn button
    public void EndTurn() {
      endTurnButton.interactable = false;
      isPlayerTurn = false;
      StartCoroutine(EnemyTurn());
    }
    </code></pre>
            <p>
              Every time a player moves, a new shortest path has to be
              calculated. The pathfinding works with a modified A* algorithm
              implemented by Daniil. When a player used up their moves, their
              control gets locked until their next turn. If there is no enemies
              in interest range of the pathfinder, the players' turn doesn't end
              and instead starts over. Otherwise, the enemy turn starts and is
              executed, after which the control is unlocked again and the player
              turn starts again.
            </p>
          </div>
        </div>
      </section>
    </div>

    <div id="footer"></div>
  </body>
</html>
